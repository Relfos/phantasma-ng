using System;
using System.Linq;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Phantasma.Business.CodeGen.Assembler;
using Phantasma.Business.VM.Utils;
using Phantasma.Core.Cryptography;
using Phantasma.Core.Domain;
using Phantasma.Core.Numerics;
using Phantasma.Simulator;

namespace Phantasma.LegacyTests.Exploits;

[TestClass]
public class Exploits
{
    [TestMethod]
        public void ChainTransferExploit()
        {
            var owner = PhantasmaKeys.FromWIF("L2LGgkZAdupN2ee8Rs6hpkc65zaGcLbxhbSDGq8oh6umUxxzeW25");

            var simulator = new NexusSimulator(owner);
            var nexus = simulator.Nexus;

            var user = PhantasmaKeys.Generate();

            var symbol = DomainSettings.StakingTokenSymbol;

            var chainAddressStr = Base16.Encode(simulator.Nexus.RootChain.Address.ToByteArray());
            var userAddressStr = Base16.Encode(user.Address.ToByteArray());

            simulator.BeginBlock();
            simulator.GenerateTransfer(owner, user.Address, simulator.Nexus.RootChain, DomainSettings.FuelTokenSymbol, 100000000);
            simulator.GenerateTransfer(owner, user.Address, simulator.Nexus.RootChain, DomainSettings.StakingTokenSymbol, 100000000);
            simulator.EndBlock();

            var chainAddress = simulator.Nexus.RootChain.Address;
            simulator.BeginBlock();
            var tx = simulator.GenerateTransfer(owner, chainAddress, simulator.Nexus.RootChain, symbol, 100000000);
            var block = simulator.EndBlock().First();

            var evts = block.GetEventsForTransaction(tx.Hash);
            Assert.IsTrue(evts.Any(x => x.Kind == EventKind.TokenReceive && x.Address == chainAddress));

            var token = simulator.Nexus.GetTokenInfo(simulator.Nexus.RootStorage, symbol);

            var initialBalance = simulator.Nexus.RootChain.GetTokenBalance(simulator.Nexus.RootStorage, token, chainAddress);
            Assert.IsTrue(initialBalance > 10000);

            string[] scriptString = new string[]
            {
                $"alias r5, $sourceAddress",
                $"alias r6, $targetAddress",
                $"alias r7, $amount",
                $"alias r8, $symbol",

                $"load $amount, 10000",
                $@"load $symbol, ""{symbol}""",

                $"load r11 0x{chainAddressStr}",
                $"push r11",
                $@"extcall ""Address()""",
                $"pop $sourceAddress",

                $"load r11 0x{userAddressStr}",
                $"push r11",
                $@"extcall ""Address()""",
                $"pop $targetAddress",

                $"push $amount",
                $"push $symbol",
                $"push $targetAddress",
                $"push $sourceAddress",
                "extcall \"Runtime.TransferTokens\"",
            };

            var script = AssemblerUtils.BuildScript(scriptString);

            simulator.BeginBlock();
            simulator.GenerateCustomTransaction(user, ProofOfWork.None, () =>
                ScriptUtils.BeginScript().
                    AllowGas(user.Address, Address.Null, simulator.MinimumFee, Transaction.DefaultGasLimit).
                    EmitRaw(script).
                    SpendGas(user.Address).
                    EndScript());

            try
            {
                simulator.EndBlock();
            }
            catch (Exception e)
            {
                Assert.IsTrue(e is ChainException);
            }

            var finalBalance = simulator.Nexus.RootChain.GetTokenBalance(simulator.Nexus.RootStorage, token, simulator.Nexus.RootChain.Address);
            Assert.IsTrue(initialBalance == finalBalance);
        }
}
