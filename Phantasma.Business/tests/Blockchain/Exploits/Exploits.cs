using System;
using System.Linq;
using System.Numerics;
using Phantasma.Business.Blockchain.Contracts;
using Phantasma.Business.CodeGen.Assembler;
using Phantasma.Business.Tests.Simulator;
using Phantasma.Business.VM.Utils;
using Phantasma.Core.Cryptography;
using Phantasma.Core.Domain;
using Phantasma.Core.Numerics;
using Phantasma.Core.Types;

using Xunit;

namespace Phantasma.Business.Tests.Blockchain.Exploits;

[Collection(nameof(SystemTestCollectionDefinition))]
public class Exploits
{
    [Fact]
    public void DuplicateTransferTest()
    {
        var owner = PhantasmaKeys.Generate();

        var simulator = new NexusSimulator(owner);
        var nexus = simulator.Nexus;

        var target = PhantasmaKeys.Generate();

        simulator.BeginBlock();
        var tx1 = simulator.GenerateTransfer(owner, target.Address, simulator.Nexus.RootChain, DomainSettings.FuelTokenSymbol, 1);
        var tx2 = simulator.GenerateTransfer(owner, target.Address, simulator.Nexus.RootChain, DomainSettings.FuelTokenSymbol, 1);

        Assert.True(tx1.Hash == tx2.Hash);

        simulator.EndBlock();
        Assert.False(simulator.LastBlockWasSuccessful());
    }

    [Fact]
    public void ChainTransferExploit()
    {
        var owner = PhantasmaKeys.FromWIF("L2LGgkZAdupN2ee8Rs6hpkc65zaGcLbxhbSDGq8oh6umUxxzeW25");

        var simulator = new NexusSimulator(owner);
        var nexus = simulator.Nexus;

        var user = PhantasmaKeys.Generate();

        var symbol = DomainSettings.StakingTokenSymbol;

        var chainAddressStr = Base16.Encode(simulator.Nexus.RootChain.Address.ToByteArray());
        var userAddressStr = Base16.Encode(user.Address.ToByteArray());

        simulator.BeginBlock();
        simulator.GenerateTransfer(owner, user.Address, simulator.Nexus.RootChain, DomainSettings.FuelTokenSymbol, 100000000000);
        simulator.GenerateTransfer(owner, user.Address, simulator.Nexus.RootChain, DomainSettings.StakingTokenSymbol, 10000000000);
        simulator.EndBlock();
        Assert.True(simulator.LastBlockWasSuccessful());

        var chainAddress = simulator.Nexus.RootChain.Address;
        simulator.BeginBlock();
        var tx = simulator.GenerateTransfer(owner, chainAddress, simulator.Nexus.RootChain, symbol, 100000000);
        var block = simulator.EndBlock().FirstOrDefault();
        Assert.True(simulator.LastBlockWasSuccessful());

        var evts = block.GetEventsForTransaction(tx.Hash);
        Assert.True(evts.Any(x => x.Kind == EventKind.TokenReceive && x.Address == chainAddress));

        var token = simulator.Nexus.GetTokenInfo(simulator.Nexus.RootStorage, symbol);

        var initialBalance = simulator.Nexus.RootChain.GetTokenBalance(simulator.Nexus.RootStorage, token, chainAddress);
        Assert.True(initialBalance > 10000);

        string[] scriptString = new string[]
        {
                $"alias r5, $sourceAddress",
                $"alias r6, $targetAddress",
                $"alias r7, $amount",
                $"alias r8, $symbol",

                $"load $amount, 10000",
                $@"load $symbol, ""{symbol}""",

                $"load r11 0x{chainAddressStr}",
                $"push r11",
                $@"extcall ""Address()""",
                $"pop $sourceAddress",

                $"load r11 0x{userAddressStr}",
                $"push r11",
                $@"extcall ""Address()""",
                $"pop $targetAddress",

                $"push $amount",
                $"push $symbol",
                $"push $targetAddress",
                $"push $sourceAddress",
                "extcall \"Runtime.TransferTokens\"",
        };

        var script = AssemblerUtils.BuildScript(scriptString);

        simulator.BeginBlock();
        simulator.GenerateCustomTransaction(user, ProofOfWork.None, () =>
            ScriptUtils.BeginScript().
                AllowGas(user.Address, Address.Null, simulator.MinimumFee, Transaction.DefaultGasLimit).
                EmitRaw(script).
                SpendGas(user.Address).
                EndScript());

        simulator.EndBlock();
        Assert.False(simulator.LastBlockWasSuccessful());

        var finalBalance = simulator.Nexus.RootChain.GetTokenBalance(simulator.Nexus.RootStorage, token, simulator.Nexus.RootChain.Address);
        Assert.True(initialBalance == finalBalance);
    }

    [Fact]
    public void TestPrintMoneyWithoutPermission()
    {
        var owner = PhantasmaKeys.FromWIF("L2LGgkZAdupN2ee8Rs6hpkc65zaGcLbxhbSDGq8oh6umUxxzeW25");

        var simulator = new NexusSimulator(owner);
        var nexus = simulator.Nexus;
        nexus.SetOracleReader(new OracleSimulator(nexus));

        var fuelToken = DomainSettings.FuelTokenSymbol;
        var stakingToken = DomainSettings.StakingTokenSymbol;

        //Let A be an address
        var testUserA = PhantasmaKeys.Generate();

        simulator.BeginBlock();
        simulator.GenerateTransfer(owner, testUserA.Address, nexus.RootChain, fuelToken, 10000000000);
        simulator.GenerateTransfer(owner, testUserA.Address, nexus.RootChain, stakingToken, 100000000);
        simulator.EndBlock();
        Assert.True(simulator.LastBlockWasSuccessful());

        var balanceBefore = nexus.RootChain.GetTokenBalance(simulator.Nexus.RootStorage, stakingToken, testUserA.Address);

        simulator.BeginBlock();
        simulator.GenerateCustomTransaction(testUserA, ProofOfWork.Minimal, () =>
            ScriptUtils.BeginScript()
                .AllowGas(testUserA.Address, Address.Null, simulator.MinimumFee, 99999)
                .CallInterop("Runtime.MintTokens", "S3dP2jjf1jUG9nethZBWbnu9a6dFqB7KveTWU7znis6jpDy", testUserA.Address, stakingToken, 100000000).
                SpendGas(testUserA.Address)
                .EndScript());
        simulator.EndBlock();
        Assert.False(simulator.LastBlockWasSuccessful());

        var balanceAfter = nexus.RootChain.GetTokenBalance(simulator.Nexus.RootStorage, stakingToken, testUserA.Address);
        Assert.True(balanceAfter == balanceBefore, $"{balanceAfter} == {balanceBefore}");
        Assert.False(balanceAfter == balanceBefore + 100000000);
    }

    public struct crownStruct
    {
        public Address staker;
        public Timestamp date;
    }

    [Fact]
    public void TestPrintCrowns()
    {
        var owner = PhantasmaKeys.FromWIF("L2LGgkZAdupN2ee8Rs6hpkc65zaGcLbxhbSDGq8oh6umUxxzeW25");

        var simulator = new NexusSimulator(owner);
        var nexus = simulator.Nexus;
        nexus.SetOracleReader(new OracleSimulator(nexus));

        var fuelToken = DomainSettings.FuelTokenSymbol;
        var stakingToken = DomainSettings.StakingTokenSymbol;

        //Let A be an address
        var testUserA = PhantasmaKeys.Generate();

        var crownRom = new crownStruct
        {
            staker = testUserA.Address,
            date = Timestamp.Now
        };

        var crownRam = 1;

        simulator.BeginBlock();
        simulator.GenerateTransfer(owner, testUserA.Address, nexus.RootChain, fuelToken, 10000000000);
        simulator.GenerateTransfer(owner, testUserA.Address, nexus.RootChain, stakingToken, 100000000);
        simulator.EndBlock();
        Assert.True(simulator.LastBlockWasSuccessful());

        var reward = new StakeReward(testUserA.Address, Timestamp.Now);

        var balanceBefore = nexus.RootChain.GetTokenBalance(simulator.Nexus.RootStorage, "CROWN", testUserA.Address);


        simulator.BeginBlock();
        simulator.GenerateCustomTransaction(testUserA, ProofOfWork.Minimal, () =>
            ScriptUtils.BeginScript()
                .AllowGas(testUserA.Address, Address.Null, simulator.MinimumFee, 99999)
                .CallInterop("Runtime.MintToken", "S3d79FvexQeerRioAY3pGYpNPFx7oJkMV4KazdTHdGDA5iy", testUserA.Address, DomainSettings.RewardTokenSymbol, VMObject.FromStruct(reward), new byte[0], 0)
                .SpendGas(testUserA.Address)
                .EndScript());
        simulator.EndBlock();
        Assert.False(simulator.LastBlockWasSuccessful());

        var balanceAfter = nexus.RootChain.GetTokenBalance(simulator.Nexus.RootStorage, "CROWN", testUserA.Address);
        Assert.True(balanceAfter == balanceBefore, $"{balanceAfter} != {balanceBefore}");
    }

    [Fact]
    public void TestInfiniteTokenTransfer()
    {
        var owner = PhantasmaKeys.Generate();

        var simulator = new NexusSimulator(owner);
        var nexus = simulator.Nexus;

        simulator.BeginBlock();
        simulator.GenerateToken(owner, "INFI", "infinity token", 0, 8,
            TokenFlags.Fungible | TokenFlags.Transferable | TokenFlags.Divisible);
        simulator.EndBlock();
        Assert.True(simulator.LastBlockWasSuccessful());

        var user = PhantasmaKeys.Generate();

        var infiToken = nexus.GetTokenInfo(nexus.RootStorage, "INFI");

        var infiAmount = 1000 * UnitConversion.GetUnitValue(infiToken.Decimals);

        simulator.BeginBlock();
        simulator.GenerateTransfer(owner, user.Address, nexus.RootChain, DomainSettings.FuelTokenSymbol, 100000000);
        simulator.MintTokens(owner, owner.Address, infiToken.Symbol, infiAmount);
        simulator.EndBlock();
        Assert.True(simulator.LastBlockWasSuccessful());

        var balance = nexus.RootChain.GetTokenBalance(simulator.Nexus.RootStorage, infiToken, owner.Address);
        Assert.True(balance == infiAmount);

        simulator.BeginBlock();
        simulator.GenerateTransfer(owner, user.Address, nexus.RootChain, infiToken.Symbol, infiAmount);
        simulator.EndBlock();
        Assert.True(simulator.LastBlockWasSuccessful());

        balance = nexus.RootChain.GetTokenBalance(simulator.Nexus.RootStorage, infiToken, user.Address);
        Assert.True(balance == infiAmount);
    }

    [Fact]
    public void ForFalsifyIsWitness()
    {
        var owner = PhantasmaKeys.Generate();
        var testName = "test_name";

        var simulator = new NexusSimulator(owner);
        var nexus = simulator.Nexus;

        var user = PhantasmaKeys.Generate();

        var symbol = DomainSettings.StakingTokenSymbol;
        var baseSoul = UnitConversion.ToBigInteger(100m, DomainSettings.StakingTokenDecimals);
        var baseKcal = UnitConversion.ToBigInteger(100m, DomainSettings.FuelTokenDecimals);

        var chainAddressStr = Base16.Encode(simulator.Nexus.RootChain.Address.ToByteArray());
        var userAddressStr = Base16.Encode(user.Address.ToByteArray());

        var sysAddress = SmartContract.GetAddressForNative(NativeContractKind.Stake);

        simulator.BeginBlock();
        simulator.GenerateTransfer(owner, user.Address, simulator.Nexus.RootChain, DomainSettings.StakingTokenSymbol, baseSoul);
        simulator.GenerateTransfer(owner, user.Address, simulator.Nexus.RootChain, DomainSettings.FuelTokenSymbol, baseKcal*2);
        simulator.GenerateTransfer(owner, sysAddress, simulator.Nexus.RootChain, DomainSettings.FuelTokenSymbol, baseKcal);
        simulator.EndBlock();
        Assert.True(simulator.LastBlockWasSuccessful());

        
        // Stake
        simulator.BeginBlock();
        simulator.GenerateCustomTransaction(user, ProofOfWork.None, () =>
            ScriptUtils.BeginScript()
                .AllowGas(user.Address, Address.Null, simulator.MinimumFee, simulator.MinimumGasLimit)
                .CallContract(NativeContractKind.Stake, nameof(StakeContract.Stake), user.Address, baseSoul/2)
                .SpendGas(user.Address)
                .EndScript());
        simulator.EndBlock();
        Assert.True(simulator.LastBlockWasSuccessful());
        
        // Simuale imperssionation of the IsWitness function
        simulator.BeginBlock();
        simulator.GenerateCustomTransaction(user, ProofOfWork.None, () =>
            ScriptUtils.BeginScript()
                .AllowGas(sysAddress, Address.Null, simulator.MinimumFee, simulator.MinimumGasLimit)
                .CallContract(NativeContractKind.Account, nameof(AccountContract.RegisterName), sysAddress.Text, testName)
                //.CallInterop("Runtime.IsWitness", sysAddress, chainAddressStr, userAddressStr)
                .SpendGas(sysAddress)
                .EndScript());
        simulator.EndBlock();
        Assert.False(simulator.LastBlockWasSuccessful());
        
        // Simuale imperssionation of the IsWitness function
        simulator.BeginBlock();
        simulator.GenerateCustomTransaction(user, ProofOfWork.None, () =>
            ScriptUtils.BeginScript()
                .AllowGas(owner.Address, Address.Null, simulator.MinimumFee, simulator.MinimumGasLimit)
                .CallContract(NativeContractKind.Account, nameof(AccountContract.RegisterName), owner.Address, testName)
                //.CallInterop("Runtime.IsWitness", sysAddress, chainAddressStr, userAddressStr)
                .SpendGas(owner.Address)
                .EndScript());
        simulator.EndBlock();
        Assert.False(simulator.LastBlockWasSuccessful());
        
        // Make a valid one just to check
        simulator.BeginBlock();
        simulator.GenerateCustomTransaction(user, ProofOfWork.None, () =>
            ScriptUtils.BeginScript()
                .AllowGas(user.Address, Address.Null, simulator.MinimumFee, simulator.MinimumGasLimit)
                .CallContract(NativeContractKind.Account, nameof(AccountContract.RegisterName), user.Address, testName)
                //.CallInterop("Runtime.IsWitness", sysAddress, chainAddressStr, userAddressStr)
                .SpendGas(user.Address)
                .EndScript());
        simulator.EndBlock();
        Assert.True(simulator.LastBlockWasSuccessful());
    }

    [Fact]
    public void ForClaimUserForMe()
    {
        var owner = PhantasmaKeys.Generate();
        
        var simulator = new NexusSimulator(owner);
        var nexus = simulator.Nexus;

        var user = PhantasmaKeys.Generate();

        var symbol = DomainSettings.StakingTokenSymbol;
        var baseSoul = UnitConversion.ToBigInteger(100m, DomainSettings.StakingTokenDecimals);
        var baseKcal = UnitConversion.ToBigInteger(100m, DomainSettings.FuelTokenDecimals);

        var chainAddressStr = Base16.Encode(simulator.Nexus.RootChain.Address.ToByteArray());
        var userAddressStr = Base16.Encode(user.Address.ToByteArray());
        var sysAddress = SmartContract.GetAddressForNative(NativeContractKind.Stake);
        
        // Init tokens
        simulator.BeginBlock();
        simulator.GenerateTransfer(owner, user.Address, simulator.Nexus.RootChain, DomainSettings.FuelTokenSymbol, baseKcal);
        simulator.GenerateTransfer(owner, user.Address, simulator.Nexus.RootChain, DomainSettings.StakingTokenSymbol, baseSoul);
        simulator.GenerateTransfer(owner, sysAddress, simulator.Nexus.RootChain, DomainSettings.FuelTokenSymbol, baseKcal);
        simulator.GenerateTransfer(owner, sysAddress, simulator.Nexus.RootChain, DomainSettings.StakingTokenSymbol, baseSoul*2);
        simulator.EndBlock();
        Assert.True(simulator.LastBlockWasSuccessful());
        
        // Stake for testing
        simulator.BeginBlock();
        simulator.GenerateCustomTransaction(user, ProofOfWork.Minimal, () =>
            ScriptUtils.BeginScript()
                .AllowGas(user.Address, Address.Null, simulator.MinimumFee, simulator.MinimumGasLimit)
                .CallContract(NativeContractKind.Stake, nameof(StakeContract.Stake), user.Address, baseSoul/2)
                .SpendGas(user.Address)
                .EndScript());
        simulator.EndBlock();
        Assert.True(simulator.LastBlockWasSuccessful());
        
        // Simuale imperssionation of the IsWitness function
        var tokensBefore = simulator.Nexus.RootChain.GetTokenBalance(simulator.Nexus.RootStorage,  DomainSettings.FuelTokenSymbol, user.Address);

        simulator.BeginBlock();
        var tx = simulator.GenerateCustomTransaction(user, ProofOfWork.None, () =>
            ScriptUtils.BeginScript()
                .AllowGas(sysAddress, Address.Null, simulator.MinimumFee, simulator.MinimumGasLimit)
                .CallContract(NativeContractKind.Stake, nameof(StakeContract.Claim), user.Address, sysAddress)
                .SpendGas(sysAddress)
                .EndScript());
        simulator.EndBlock();
        Assert.False(simulator.LastBlockWasSuccessful());
        
        simulator.BeginBlock();
        tx = simulator.GenerateCustomTransaction(user, ProofOfWork.None, () =>
            ScriptUtils.BeginScript()
                .AllowGas(owner.Address, Address.Null, simulator.MinimumFee, simulator.MinimumGasLimit)
                .CallContract(NativeContractKind.Stake, nameof(StakeContract.Claim), user.Address, owner.Address)
                .CallContract(NativeContractKind.Stake, nameof(StakeContract.Claim), user.Address, owner.Address)
                .SpendGas(owner.Address)
                .EndScript());
        simulator.EndBlock();
        Assert.False(simulator.LastBlockWasSuccessful());
        
        var tokensAfter = simulator.Nexus.RootChain.GetTokenBalance(simulator.Nexus.RootStorage, DomainSettings.FuelTokenSymbol, user.Address);
        var txCost = simulator.Nexus.RootChain.GetTransactionFee(tx);

        Assert.Equal(tokensBefore, tokensAfter);

        simulator.TimeSkipDays(1, true);
        simulator.TimeSkipDays(1);
        
        // Make a valid one just to check
        var unclaimed =
            simulator.InvokeContract(NativeContractKind.Stake, nameof(StakeContract.GetUnclaimed), user.Address).AsNumber();

        
        simulator.BeginBlock();
        tx = simulator.GenerateCustomTransaction(user, ProofOfWork.Minimal, () =>
            ScriptUtils.BeginScript()
                .AllowGas(user.Address, Address.Null, simulator.MinimumFee, simulator.MinimumGasLimit)
                .CallContract(NativeContractKind.Stake, nameof(StakeContract.Claim), user.Address, user.Address)
                .SpendGas(user.Address)
                .EndScript());
        simulator.EndBlock();
        Assert.True(simulator.LastBlockWasSuccessful());
        txCost = simulator.Nexus.RootChain.GetTransactionFee(tx);
        
        BigInteger stakedAmount =
            simulator.Nexus.RootChain.InvokeContractAtTimestamp(simulator.Nexus.RootStorage, simulator.CurrentTime, NativeContractKind.Stake, nameof(StakeContract.GetStake), user.Address).AsNumber();
        Assert.Equal(stakedAmount, baseSoul/2);

        var tokensAfterValid = simulator.Nexus.RootChain.GetTokenBalance(simulator.Nexus.RootStorage, DomainSettings.FuelTokenSymbol, user.Address);
        
        Assert.NotEqual(tokensAfter, tokensAfterValid);
        Assert.Equal(tokensAfter, tokensAfterValid-unclaimed+txCost);
    }

    [Fact]
    public void MigrateStakeToMyAddress()
    {
        var owner = PhantasmaKeys.Generate();
        
        var simulator = new NexusSimulator(owner);
        var nexus = simulator.Nexus;

        var user = PhantasmaKeys.Generate();
        var user2 = PhantasmaKeys.Generate();

        var symbol = DomainSettings.StakingTokenSymbol;
        var baseSoul = UnitConversion.ToBigInteger(100m, DomainSettings.StakingTokenDecimals);
        var baseKcal = UnitConversion.ToBigInteger(100m, DomainSettings.FuelTokenDecimals);

        var chainAddressStr = Base16.Encode(simulator.Nexus.RootChain.Address.ToByteArray());
        var userAddressStr = Base16.Encode(user.Address.ToByteArray());
        var sysAddress = SmartContract.GetAddressForNative(NativeContractKind.Stake);
        
        // Init tokens
        simulator.BeginBlock();
        simulator.GenerateTransfer(owner, user.Address, simulator.Nexus.RootChain, DomainSettings.FuelTokenSymbol, baseKcal);
        simulator.GenerateTransfer(owner, user.Address, simulator.Nexus.RootChain, DomainSettings.StakingTokenSymbol, baseSoul);
        simulator.GenerateTransfer(owner, sysAddress, simulator.Nexus.RootChain, DomainSettings.FuelTokenSymbol, baseKcal);
        simulator.GenerateTransfer(owner, sysAddress, simulator.Nexus.RootChain, DomainSettings.StakingTokenSymbol, baseSoul*2);
        simulator.EndBlock();
        Assert.True(simulator.LastBlockWasSuccessful());
        
        // Stake for testing
        simulator.BeginBlock();
        simulator.GenerateCustomTransaction(user, ProofOfWork.Minimal, () =>
            ScriptUtils.BeginScript()
                .AllowGas(user.Address, Address.Null, simulator.MinimumFee, simulator.MinimumGasLimit)
                .CallContract(NativeContractKind.Stake, nameof(StakeContract.Stake), user.Address, baseSoul/2)
                .SpendGas(user.Address)
                .EndScript());
        simulator.EndBlock();
        Assert.True(simulator.LastBlockWasSuccessful());
        
        var tokensBefore = simulator.Nexus.RootChain.GetTokenBalance(simulator.Nexus.RootStorage,  DomainSettings.FuelTokenSymbol, user.Address);
        var unclaimedBefore = simulator.InvokeContract(NativeContractKind.Stake, nameof(StakeContract.GetUnclaimed), user.Address).AsNumber();

        // Simuale imperssionation of the IsWitness function to migrate
        simulator.BeginBlock();
        var tx = simulator.GenerateCustomTransaction(user, ProofOfWork.None, () =>
            ScriptUtils.BeginScript()
                .AllowGas(owner.Address, Address.Null, simulator.MinimumFee, simulator.MinimumGasLimit)
                .CallContract(NativeContractKind.Account, nameof(AccountContract.Migrate), owner.Address, user.Address)
                .SpendGas(owner.Address)
                .EndScript());
        simulator.EndBlock();
        Assert.False(simulator.LastBlockWasSuccessful());

        var tokensAfter = simulator.Nexus.RootChain.GetTokenBalance(simulator.Nexus.RootStorage, DomainSettings.FuelTokenSymbol, user.Address);
        var txCost = simulator.Nexus.RootChain.GetTransactionFee(tx);
        BigInteger stakedAmount =
            simulator.Nexus.RootChain.InvokeContractAtTimestamp(simulator.Nexus.RootStorage, simulator.CurrentTime, NativeContractKind.Stake, nameof(StakeContract.GetStake), user.Address).AsNumber();
        Assert.Equal(stakedAmount, baseSoul/2);
        Assert.Equal(tokensBefore, tokensAfter);
        
        simulator.BeginBlock();
        tx = simulator.GenerateCustomTransaction(user, ProofOfWork.None, () =>
            ScriptUtils.BeginScript()
                .AllowGas(user.Address, Address.Null, simulator.MinimumFee, simulator.MinimumGasLimit)
                .CallContract(NativeContractKind.Account, nameof(AccountContract.Migrate), owner.Address, user.Address)
                .SpendGas(user.Address)
                .EndScript());
        simulator.EndBlock();
        Assert.False(simulator.LastBlockWasSuccessful());
        
        // Make a valid one just to check
        var unclaimed = simulator.InvokeContract(NativeContractKind.Stake, nameof(StakeContract.GetUnclaimed), user.Address).AsNumber();
        Assert.Equal(unclaimedBefore, unclaimed);

        // Valid Migrate
        simulator.BeginBlock();
        tx = simulator.GenerateCustomTransaction(user, ProofOfWork.None, () =>
            ScriptUtils.BeginScript()
                .AllowGas(user.Address, Address.Null, simulator.MinimumFee, simulator.MinimumGasLimit)
                .CallContract(NativeContractKind.Account, nameof(AccountContract.Migrate), user.Address, user2.Address)
                .SpendGas(user.Address)
                .EndScript());
        simulator.EndBlock();
        Assert.True(simulator.LastBlockWasSuccessful());
        
        var unclaimedAfter = simulator.InvokeContract(NativeContractKind.Stake, nameof(StakeContract.GetUnclaimed), user.Address).AsNumber();
        Assert.NotEqual(unclaimed, unclaimedAfter);
        Assert.Equal(0, unclaimedAfter);
    }

    [Fact]
    public void TestKCALDeletion()
    {
        var owner = PhantasmaKeys.Generate();
        
        var simulator = new NexusSimulator(owner);
        var nexus = simulator.Nexus;

        var user = PhantasmaKeys.Generate();
        var user2 = PhantasmaKeys.Generate();

        var symbol = DomainSettings.StakingTokenSymbol;
        var baseSoul = UnitConversion.ToBigInteger(100m, DomainSettings.StakingTokenDecimals);
        var baseKcal = UnitConversion.ToBigInteger(100m, DomainSettings.FuelTokenDecimals);

        var chainAddressStr = Base16.Encode(simulator.Nexus.RootChain.Address.ToByteArray());
        var userAddressStr = Base16.Encode(user.Address.ToByteArray());
        var sysAddress = SmartContract.GetAddressForNative(NativeContractKind.Stake);
        var kcalAddress = SmartContract.GetAddressFromContractName("KCAL");
        
        // Init tokens
        simulator.BeginBlock();
        simulator.GenerateTransfer(owner, user.Address, simulator.Nexus.RootChain, DomainSettings.FuelTokenSymbol, baseKcal);
        simulator.GenerateTransfer(owner, user.Address, simulator.Nexus.RootChain, DomainSettings.StakingTokenSymbol, baseSoul);
        simulator.GenerateTransfer(owner, sysAddress, simulator.Nexus.RootChain, DomainSettings.FuelTokenSymbol, baseKcal);
        simulator.GenerateTransfer(owner, sysAddress, simulator.Nexus.RootChain, DomainSettings.StakingTokenSymbol, baseSoul*2);
        simulator.EndBlock();
        Assert.True(simulator.LastBlockWasSuccessful());
        
        // Delete KCAL 
        simulator.BeginBlock();
        simulator.GenerateCustomTransaction(user, ProofOfWork.None, () =>
            ScriptUtils.BeginScript()
                .AllowGas(user.Address, Address.Null, simulator.MinimumFee, simulator.MinimumGasLimit)
                .CallInterop("Data.Delete", "KCAL")
                .SpendGas(user.Address)
                .EndScript());
        simulator.EndBlock();
        Assert.False(simulator.LastBlockWasSuccessful());
        
        simulator.BeginBlock();
        var tx = simulator.GenerateCustomTransaction(owner, ProofOfWork.Minimal, () =>
            ScriptUtils.BeginScript()
                .AllowGas(owner.Address, Address.Null, simulator.MinimumFee, simulator.MinimumGasLimit)
                .CallInterop("Runtime.KillContract", owner.Address, "KCAL")
                .SpendGas(owner.Address)
                .EndScript());
        simulator.EndBlock();
        Assert.False(simulator.LastBlockWasSuccessful());

        var ownerBalance = simulator.Nexus.RootChain.GetTokenBalance(simulator.Nexus.RootStorage, "KCAL", owner.Address);
        Assert.True(ownerBalance != 0);
        
        simulator.BeginBlock();
        tx = simulator.GenerateCustomTransaction(owner, ProofOfWork.Minimal, () =>
            ScriptUtils.BeginScript()
                .AllowGas(owner.Address, Address.Null, simulator.MinimumFee, simulator.MinimumGasLimit)
                .CallInterop("List.Clear", "KCAL")
                .SpendGas(owner.Address)
                .EndScript());
        simulator.EndBlock();
        Assert.False(simulator.LastBlockWasSuccessful());
        
        simulator.BeginBlock();
        tx = simulator.GenerateCustomTransaction(owner, ProofOfWork.Minimal, () =>
            ScriptUtils.BeginScript()
                .AllowGas(owner.Address, Address.Null, simulator.MinimumFee, simulator.MinimumGasLimit)
                .CallInterop("List.Clear", "_balances")
                .SpendGas(owner.Address)
                .EndScript());
        simulator.EndBlock();
        Assert.False(simulator.LastBlockWasSuccessful());
        
        simulator.BeginBlock();
        tx = simulator.GenerateCustomTransaction(owner, ProofOfWork.Minimal, () =>
            ScriptUtils.BeginScript()
                .AllowGas(owner.Address, Address.Null, simulator.MinimumFee, simulator.MinimumGasLimit)
                .CallInterop("Map.Clear", "_balances")
                .SpendGas(owner.Address)
                .EndScript());
        simulator.EndBlock();
        Assert.False(simulator.LastBlockWasSuccessful());
    }

    private static string KCAL_CONTRACT_PVM = "";
    private static string KCAL_CONTRACT_ABI = "";

    [Fact (Skip = "not implemented yet")]
    public void TestOverrideKCALToken()
    {
        var owner = PhantasmaKeys.Generate();
        
        var simulator = new NexusSimulator(owner);
        var nexus = simulator.Nexus;

        var user = PhantasmaKeys.Generate();
        var user2 = PhantasmaKeys.Generate();

        var symbol = DomainSettings.StakingTokenSymbol;
        var baseSoul = UnitConversion.ToBigInteger(60000m, DomainSettings.StakingTokenDecimals);
        var baseKcal = UnitConversion.ToBigInteger(10, DomainSettings.FuelTokenDecimals);

        var chainAddressStr = Base16.Encode(simulator.Nexus.RootChain.Address.ToByteArray());
        var userAddressStr = Base16.Encode(user.Address.ToByteArray());
        var sysAddress = SmartContract.GetAddressForNative(NativeContractKind.Stake);
        var kcalAddress = SmartContract.GetAddressFromContractName("KCAL");
        
        // Init tokens
        simulator.BeginBlock();
        simulator.GenerateTransfer(owner, user.Address, simulator.Nexus.RootChain, DomainSettings.FuelTokenSymbol, baseKcal);
        //simulator.GenerateTransfer(owner, user.Address, simulator.Nexus.RootChain, DomainSettings.StakingTokenSymbol, baseSoul);
        simulator.EndBlock();
        Assert.True(simulator.LastBlockWasSuccessful());
        
        // Stake for testing
        simulator.BeginBlock();
        simulator.GenerateCustomTransaction(user, ProofOfWork.Minimal, () =>
            ScriptUtils.BeginScript()
                .AllowGas(user.Address, Address.Null, simulator.MinimumFee, simulator.MinimumGasLimit)
                .CallContract(NativeContractKind.Stake, nameof(StakeContract.Stake), user.Address, UnitConversion.ToBigInteger(50000, DomainSettings.StakingTokenDecimals))
                .SpendGas(user.Address)
                .EndScript());
        simulator.EndBlock();
        Assert.True(simulator.LastBlockWasSuccessful());
        
        // Deploy Contract
        var KCALContractPVM = Base16.Decode(KCAL_CONTRACT_PVM);
        var KCALContractABI = Base16.Decode(KCAL_CONTRACT_ABI);
            
        var contractName = "KCAL";
        Address KCALAddress = SmartContract.GetAddressFromContractName(contractName);
            
        simulator.BeginBlock();
        simulator.GenerateCustomTransaction(owner, ProofOfWork.Minimal,
            () => ScriptUtils.BeginScript()
                .AllowGas(owner.Address, Address.Null, simulator.MinimumFee, 10000000)
                .CallInterop("Nexus.CreateToken", owner.Address, KCALContractPVM, KCALContractABI)
                .SpendGas(owner.Address)
                .EndScript());
        simulator.GenerateTransfer(owner, KCALAddress, nexus.RootChain, DomainSettings.StakingTokenSymbol, UnitConversion.ToBigInteger(50, DomainSettings.StakingTokenDecimals));
        simulator.GenerateCustomTransaction(owner, ProofOfWork.Minimal,
            () => ScriptUtils.BeginScript()
                .AllowGas(owner.Address, Address.Null, simulator.MinimumFee, simulator.MinimumGasLimit)
                .CallContract(NativeContractKind.Stake, nameof(StakeContract.Stake), KCALAddress,  UnitConversion.ToBigInteger(50, DomainSettings.StakingTokenDecimals))
                .SpendGas(owner.Address)
                .EndScript());
        simulator.EndBlock();
        Assert.False(simulator.LastBlockWasSuccessful(), "Deploying KCAL Contract Passed... ISSUE");
    }

}
